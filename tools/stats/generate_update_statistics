#!/usr/bin/ruby -w
# ***** BEGIN LICENSE BLOCK *****
# Version: MPL 1.1/GPL 2.0/LGPL 2.1
#
# The contents of this file are subject to the Mozilla Public License Version
# 1.1 (the "License"); you may not use this file except in compliance with
# the License. You may obtain a copy of the License at
# http://www.mozilla.org/MPL/
#
# Software distributed under the License is distributed on an "AS IS" basis,
# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
# for the specific language governing rights and limitations under the
# License.
#
# The Original Code is generate_update_statistics.
#
# The Initial Developer of the Original Code is
# Stuart Morgan
# Portions created by the Initial Developer are Copyright (C) 2011
# the Initial Developer. All Rights Reserved.
#
# Contributor(s):
#   Stuart Morgan <stuart.morgan@alumni.case.edu> (Original Author)
#
# Alternatively, the contents of this file may be used under the terms of
# either the GNU General Public License Version 2 or later (the "GPL"), or
# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
# in which case the provisions of the GPL or the LGPL are applicable instead
# of those above. If you wish to allow use of your version of this file only
# under the terms of either the GPL or the LGPL, and not to allow others to
# use your version of this file under the terms of the MPL, indicate your
# decision by deleting the provisions above and replace them with the notice
# and other provisions required by the GPL or the LGPL. If you do not delete
# the provisions above, a recipient may use your version of this file under
# the terms of any one of the MPL, the GPL or the LGPL.
#
# ***** END LICENSE BLOCK *****

require 'date'
require 'set'

# IP addresses to filter out of the logs. For readability, these are
# string/regex hybrids. The first three octets should just be numbers, and the
# octet separators will be escaped automatically. The last octet will be
# treated as a regex (or if blank, as .*).
$bad_ips = [
  '63.245.210.43',
  '72.10.105.23',
  '75.135.19.219',
  '97.119.20.170',
  '97.119.24.98',
  '149.150.236.189',
  '149.150.236.250',
  '189.108.14.138',
  '200.19.92.',
  '203.42.177.1[6-9]',
  '204.234.25.253',
  '204.234.28.',
  '205.202.243.2[3-9]',
  '205.202.243.3.',
  '205.202.243.4[0-7]',
]

# Keys for the various printed sections. These are listed explicitly, rather
# than generated dynamically from the data, in order to match the spreadsheet.
$by_arch_keys = ['x86', 'ppc']
$by_os_keys = ['10.6', '10.5', '10.4', '10.3']
$by_version_keys = [
  '2.1a1',
  '2.0.7', '2.0.6', '2.0.5', '2.0.4', '2.0.3', '2.0.2', '2.0.1', '2.0',
  '2.0b4', '2.0b3', '2.0b2', '2.0b1', '2.0a1',
  '1.6.11', '1.6.10', '1.6.9', '1.6.8', '1.6.7', '1.6.6', '1.6.5', '1.6.4',
  '1.6.3', '1.6.2', '1.6.1', '1.6', 
]
$by_version_and_os_keys = [
  ['2.1', $by_os_keys[0..-2]],
  ['2.0', $by_os_keys[0..-2]],
  ['1.6', $by_os_keys],
]
# The major version to print language counts for
$language_count_version = "2.0"

def main
  print_usage if ARGV.length < 1
  command = ARGV.shift
  if (command == 'counts')
    handle_command_counts(ARGV)
  elsif (command == 'dump-ips')
    handle_command_dump_ips(ARGV)
  else
    print_usage
  end
end

# Print usage info and then exit
def print_usage
  program = File.basename($0)
  puts <<EOF
Usage:"
  #{program} counts <date>[,<date>] <caminobrowser.org-ssl_log path>
        [ <caminobrowser.org-ssl_log path> ...]
    Generates ping count to add to the tracking spreadsheet. If given one date,
    data is generated for only that date; if two, data is generated for all
    dates in that range (inclusive).

  #{program} dump-ips <threshold> <caminobrowser.org-ssl_log path>
        [ <caminobrowser.org-ssl_log path> ...]
    Lists all IPs that aren't already blacklisted and have more than |threshold|
    pings in a day, in descending order of the max number of pings, along with
    the ping counts for each day in the log files.
EOF
  exit
end

# Handle the top-level 'counts' command.
def handle_command_counts(arguments)
  print_usage if arguments.length < 2

  date_range = arguments.shift.split(',')
  start_date = Date.parse(date_range[0])
  end_date = Date.parse(date_range[-1])

  pings = load_filtered_pings(arguments)
  pings_by_date = partition_pings_by_attribute(pings, :date_str)

  (start_date..end_date).each do |date|
    print_date_heading(date)
    print_spreadsheet_stats(pings_by_date[date.date_str])
  end
end

# Handle the top-level 'dump-ips' command.
def handle_command_dump_ips(arguments)
  print_usage if arguments.length < 2
  threshold = Integer(arguments.shift)
  pings = load_filtered_pings(arguments)
  counts = count_pings_by_attribute_pair(pings, :ip, :date_str)

  dates = Set.new
  counts.values.each do |date_hash|
    dates.merge(date_hash.keys)
  end
  dates = dates.map {|date_str| Date.parse(date_str) }.sort
  print_table_line(nil, dates.map {|date| date.strftime("%m/%d") })

  counts.keys.sort_by {|ip| counts[ip].values.max }.reverse.each do |ip|
    daily_pings = counts[ip]
    break if counts[ip].values.max < threshold
    print_table_line(ip, dates.map {|date| daily_pings[date.date_str] || 0 })
  end
end

# Prints one line of a table.
def print_table_line(row_label, cells)
  print row_label ? (row_label.rjust(15) + " |") : (" " * 17)
  cells.each {|cell| print cell.to_s.rjust(7) }
  print "\n"
end

def print_spreadsheet_stats(pings)
  arch_count = count_pings_by_attribute(pings, :arch)
  version_count = count_pings_by_attribute(pings, :version)
  os_and_version_count = count_pings_by_attribute_pair(pings, :major_os,
                                                       :major_version)
  version_lang_count = count_pings_by_attribute_pair(pings, :major_version,
                                                     :lang)

  puts pings.length
  $by_arch_keys.each do |arch|
    print_count(arch_count[arch])
  end
  print_heading("By OS")
  $by_os_keys.each do |os|
    print_count(os_and_version_count[os].values.sum)
  end
  print_heading("By Version")
  $by_version_keys.each do |version|
    print_count(version_count[version])
  end
  print_heading("By Version and OS")
  $by_version_and_os_keys.each do |keys|
    major_version = keys[0]
    keys[1].each do |os|
      print_count(os_and_version_count[os][major_version])
    end
  end
  print_heading("#{$language_count_version} l10n")
  language_counts = version_lang_count[$language_count_version]
  language_counts.keys.sort.each do |lang|
    puts "#{language_counts[lang]} lang=#{lang}"
  end
end

# Prints a date heading
def print_date_heading(date)
  puts "\n===================================="
  puts date.strftime
  puts "===================================="
end

# Prints a section heading
def print_heading(heading)
  puts "=================="
  puts heading
end

# Prints a count, handling nil values correctly.
def print_count(count)
  puts count || 0
end

# Returns a array of pings extracted from the given files, with pings from bad
# IPs removed.
def load_filtered_pings(files)
  pings = load_files(files)
  pings.reject! {|ping| ping.from_bad_ip_address }
end

# Returns an array of ping data extracted from the given files.
def load_files(files)
  pings = []
  files.each do |file|
    File.foreach(file) do |line|
      next unless UpdatePing.request_is_update_ping(line)
      ping = UpdatePing.new(line)
      pings.push(ping)
    end
  end
  return pings
end

# Prints the ping counts by OS+arch pair.
# TODO: Expose this as a flag; its currently unused.
def print_os_arch_counts(pings)
  arch_os_count = {}
  pings.each do |ping|
    key = "#{ping.major_os}-#{ping.arch}"
    arch_os_count[key] ||= 0
    arch_os_count[key] += 1
  end
  arch_os_count.keys.sort.reverse.each do |key|
    puts "#{key} : #{arch_os_count[key]}"
  end
end

# Given an array of pings and a ping attribute, returns a hash mapping each
# unique value of the attribute to an array of pings with that value.
def partition_pings_by_attribute(pings, attribute)
  partitions = {}
  pings.each do |ping|
    key = ping.send attribute
    partitions[key] ||= []
    partitions[key].push(ping)
  end
  return partitions
end

# Given an array of pings and a ping attribute, returns a hash mapping each
# unique value of the attribute to the number of pings with that value
def count_pings_by_attribute(pings, attribute)
  counts = {}
  pings.each do |ping|
    key = ping.send attribute
    counts[key] ||= 0
    counts[key] += 1
  end
  return counts
end

# Given an array of pings and two ping attributes, returns a two-dimensional
# hash of the counts of pings matching both attributes.
def count_pings_by_attribute_pair(pings, attribute, subattribute)
  counts = {}
  pings.each do |ping|
    key1 = ping.send attribute
    key2 = ping.send subattribute
    counts[key1] ||= {}
    counts[key1][key2] ||= 0
    counts[key1][key2] += 1
  end
  return counts
end

# Creates and returns the regex to use for testing for bad IP addresses.
def create_bad_ip_regex
  bad_ip_patterns = $bad_ips.collect {|ip|
    octets = ip.split('.', 4)
    octets[3] = '.*' if octets[3].empty?
    octets.join('\.')
  }
  return Regexp.compile("^(#{ bad_ip_patterns.join('|') })$")
end

class Date
  # Returns a string representation of the given date that matches an
  # UpdatePing's date_str attribute.
  def date_str
    return strftime("%d/%b/%Y")
  end
end


# A object representing a specific update ping.
class UpdatePing
  attr_accessor :ip, :date_str, :os, :arch, :version, :intl, :lang

  # Regex for parsing an upadate request log line, which looks like:
  # 12.34.56.789 - - [21/Mar/2011:01:46:46 -0700] "GET /update-check?os=10.6.6&arch=x86&version=2.0.6&intl=1&lang=es HTTP/1.1" 200 1135 "-" "Camino/2.0.6 Sparkle/1.5"
  @@ping_parsing_regex = Regexp.compile('(^[\d.]+).*?\[([^:]+):.*?os=([^&]+)&arch=([^&]+)&version=([^&I]+)(?:I[^&]*)?&intl=(\d)(?:&lang=([\w]+))?')

  # Regex for testing whether a request is for the update ping URL.
  @@ping_test_regex = Regexp.compile('GET /update-check.*Sparkle')

  # Regex for testing whether an IP should be filtered out.
  @@bad_ip_regex = create_bad_ip_regex()

  def initialize(log_line)
    match = @@ping_parsing_regex.match(log_line)
    if (!match)
      # Treat parse failures as fatal, so regex mistakes are caught.
      puts "Error: unparseable ping: '#{log_line.chomp}'"
      exit
    end
    @ip = match[1]
    # Using Date objects makes parsing several orders of magnitude more
    # expensive, so just work with strings instead.
    @date_str = match[2]
    @os = match[3]
    @arch = match[4]
    @version = match[5]
    @intl = match[6] == '1'
    @lang = match[7] || 'en'
  end

  def self.request_is_update_ping(log_line)
    return !@@ping_test_regex.match(log_line).nil?
  end

  # Returns just the major OS version (e.g., 10.5)
  def major_os
    @major_os ||= @os.split('.')[0..1].join('.')
    return @major_os
  end

  # Returns just the major Camino version (e.g., 2.1)
  def major_version
    @major_version ||= @version.split(/[.abp]/)[0..1].join('.')
    return @major_version
  end

  # Returns true if the ping is from a bad IP address
  def from_bad_ip_address
    return @@bad_ip_regex.match(@ip)
  end
end

class Array
  def sum
    inject(0) { |sum, value| sum + value }
  end
end

main
