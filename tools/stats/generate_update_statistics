#!/usr/bin/ruby -w
# ***** BEGIN LICENSE BLOCK *****
# Version: MPL 1.1/GPL 2.0/LGPL 2.1
#
# The contents of this file are subject to the Mozilla Public License Version
# 1.1 (the "License"); you may not use this file except in compliance with
# the License. You may obtain a copy of the License at
# http://www.mozilla.org/MPL/
#
# Software distributed under the License is distributed on an "AS IS" basis,
# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
# for the specific language governing rights and limitations under the
# License.
#
# The Original Code is generate_update_statistics.
#
# The Initial Developer of the Original Code is
# Stuart Morgan
# Portions created by the Initial Developer are Copyright (C) 2011
# the Initial Developer. All Rights Reserved.
#
# Contributor(s):
#   Stuart Morgan <stuart.morgan@alumni.case.edu> (Original Author)
#
# Alternatively, the contents of this file may be used under the terms of
# either the GNU General Public License Version 2 or later (the "GPL"), or
# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
# in which case the provisions of the GPL or the LGPL are applicable instead
# of those above. If you wish to allow use of your version of this file only
# under the terms of either the GPL or the LGPL, and not to allow others to
# use your version of this file under the terms of the MPL, indicate your
# decision by deleting the provisions above and replace them with the notice
# and other provisions required by the GPL or the LGPL. If you do not delete
# the provisions above, a recipient may use your version of this file under
# the terms of any one of the MPL, the GPL or the LGPL.
#
# ***** END LICENSE BLOCK *****

require 'date'

# IP addresses to filter out of the logs. For readability, these are
# string/regex hybrids. The first three octets should just be numbers, and the
# octet separators will be escaped automatically. The last octet will be
# treated as a regex (or if blank, as .*).
$bad_ips = [
  '63.245.210.43',
  '72.10.105.23',
  '75.135.19.219',
  '97.119.20.170',
  '97.119.24.98',
  '149.150.236.189',
  '149.150.236.250',
  '189.108.14.138',
  '200.19.92.',
  '203.42.177.1[6-9]',
  '204.234.25.253',
  '204.234.28.',
  '205.202.243.2[3-9]',
  '205.202.243.3.',
  '205.202.243.4[0-7]',
]

# Keys for the various printed sections. These are listed explicitly, rather
# than generated dynamically from the data, in order to match the spreadsheet.
$by_arch_keys = ['x86', 'ppc']
$by_os_keys = ['10.3', '10.4', '10.5', '10.6']
$by_version_keys = [
  '1.6.11', '1.6.10', '1.6.9', '1.6.8', '1.6.7', '1.6.6', '1.6.5', '1.6.4',
  '1.6.3', '1.6.2', '1.6.1', '1.6', 
  '2.0.7', '2.0.6', '2.0.5', '2.0.4', '2.0.3', '2.0.2', '2.0.1', '2.0',
  '2.0b4', '2.0b3', '2.0b2', '2.0b1', '2.0a1',
  '2.1a1'
]
$by_version_and_os_keys = [
  ['1.6', $by_os_keys],
  ['2.0', $by_os_keys[1..-1]],
  ['2.1', $by_os_keys[1..-1]],
]
# The major version to print language counts for
$language_count_version = "2.0"

def main
  if ARGV.length < 2
    puts "Usage: #{$0} <date> <caminobrowser.org-ssl_log path> " +
         "[ <caminobrowser.org-ssl_log path> ...]"
    exit
  end

  date = ARGV[0]
  # TODO: This is a temporary compatibility measure with the old script.
  # Once any scripts depending on this have changed, the year will become
  # part of the input and output.
  date_key = "#{date}/2011"

  log_paths = ARGV[1..-1]
  pings = load_files(log_paths)
  pings.reject! {|ping| ping.from_bad_ip_address }

  pings_by_date = partition_pings_by_attribute(pings, :date_str)
  # TODO: We can easily generate data for all dates at once, once clients
  # of the script expect that.
  print_spreadsheet_stats(date, pings_by_date[date_key])
end

# Returns an array of ping data extracted from the given files.
def load_files(files)
  pings = []
  files.each do |file|
    File.foreach(file) do |line|
      next unless UpdatePing.request_is_update_ping(line)
      ping = UpdatePing.new(line)
      pings.push(ping)
    end
  end
  return pings
end

def print_spreadsheet_stats(date, pings)
  arch_count = {}
  os_and_version_count = {}
  version_count = {}
  version_lang_count = {}
  pings.each do |ping|
    arch_count[ping.arch] ||= 0
    arch_count[ping.arch] += 1
    os_and_version_count[ping.major_os] ||= {}
    os_and_version_count[ping.major_os][ping.major_version] ||= 0
    os_and_version_count[ping.major_os][ping.major_version] += 1
    version_count[ping.version] ||= 0
    version_count[ping.version] += 1
    version_lang_count[ping.major_version] ||= {}
    version_lang_count[ping.major_version][ping.lang] ||= 0
    version_lang_count[ping.major_version][ping.lang] += 1
  end
  puts date
  puts pings.count
  $by_arch_keys.each do |arch|
    puts arch_count[arch]
  end
  print_heading("By OS")
  $by_os_keys.each do |os|
    puts os_and_version_count[os].values.sum
  end
  print_heading("By Version")
  $by_version_keys.each do |version|
    puts version_count[version]
  end
  print_heading("By Version and OS")
  $by_version_and_os_keys.each do |keys|
    major_version = keys[0]
    keys[1].each do |os|
      puts os_and_version_count[os][major_version]
    end
  end
  print_heading("#{$language_count_version} l10n")
  language_counts = version_lang_count[$language_count_version]
  language_counts.keys.sort.each do |lang|
    puts "#{language_counts[lang]} lang=#{lang}"
  end
end

# Prints a section heading
def print_heading(heading)
  puts "=================="
  puts heading
end

# Prints the ping counts by OS+arch pair.
# TODO: Expose this as a flag; its currently unused.
def print_os_arch_counts(pings)
  arch_os_count = {}
  pings.each do |ping|
    key = "#{ping.major_os}-#{ping.arch}"
    arch_os_count[key] ||= 0
    arch_os_count[key] += 1
  end
  arch_os_count.keys.sort.reverse.each do |key|
    puts "#{key} : #{arch_os_count[key]}"
  end
end

# Given an array of pings and a ping attribute, returns a hash mapping each
# unique value of the attribute to the pings with that value.
def partition_pings_by_attribute(pings, attribute)
  partitions = {}
  pings.each do |ping|
    key = ping.send attribute
    partitions[key] ||= []
    partitions[key].push(ping)
  end
  return partitions
end

# Creates and returns the regex to use for testing for bad IP addresses.
def create_bad_ip_regex
  bad_ip_patterns = $bad_ips.collect {|ip|
    octets = ip.split('.', 4)
    octets[3] = '.*' if octets[3].empty?
    octets.join('\.')
  }
  return Regexp.compile("^(#{ bad_ip_patterns.join('|') })$")
end


# A object representing a specific update ping.
class UpdatePing
  attr_accessor :ip, :date_str, :os, :arch, :version, :intl, :lang

  # Regex for parsing an upadate request log line, which looks like:
  # 12.34.56.789 - - [21/Mar/2011:01:46:46 -0700] "GET /update-check?os=10.6.6&arch=x86&version=2.0.6&intl=1&lang=es HTTP/1.1" 200 1135 "-" "Camino/2.0.6 Sparkle/1.5"
  @@ping_parsing_regex = Regexp.compile('(^[\d.]+).*?\[([^:]+):.*?os=([^&]+)&arch=([^&]+)&version=([^&I]+)(?:I[^&]*)?&intl=(\d)(?:&lang=([\w]+))?')

  # Regex for testing whether a request is for the update ping URL.
  @@ping_test_regex = Regexp.compile('GET /update-check.*Sparkle')

  # Regex for testing whether an IP should be filtered out.
  @@bad_ip_regex = create_bad_ip_regex()

  def initialize(log_line)
    match = @@ping_parsing_regex.match(log_line)
    if (!match)
      # Treat parse failures as fatal, so regex mistakes are caught.
      puts "Error: unparseable ping: '#{log_line.chomp}'"
      exit
    end
    @ip = match[1]
    # Using Date objects makes parsing several orders of magnitude more
    # expensive, so just work with strings instead.
    @date_str = match[2]
    @os = match[3]
    @arch = match[4]
    @version = match[5]
    @intl = match[6] == '1'
    @lang = match[7] || 'en'
  end

  def self.request_is_update_ping(log_line)
    return !@@ping_test_regex.match(log_line).nil?
  end

  # Returns just the major OS version (e.g., 10.5)
  def major_os
    @major_os ||= @os.split('.')[0..1].join('.')
    return @major_os
  end

  # Returns just the major Camino version (e.g., 2.1)
  def major_version
    @major_version ||= @version.split(/[.abp]/)[0..1].join('.')
    return @major_version
  end

  # Returns true if the ping is from a bad IP address
  def from_bad_ip_address
    return @@bad_ip_regex.match(@ip)
  end
end

class Array
  def sum
    inject(0) { |sum, value| sum + value }
  end
end

main
